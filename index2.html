<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Workrush</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300&display=swap" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="./assets/main.css">
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.0/gsap.min.js"></script>
		
		<style>
			body {
				
				color: #000;
				overflow-x:hidden;
				overflow-y:hidden;
				font-family: 'Nunito', sans-serif;
				background-color: #ffffff;
				background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100%25'%3E%3Cdefs%3E%3ClinearGradient id='a' gradientUnits='userSpaceOnUse' x1='0' x2='0' y1='0' y2='100%25' gradientTransform='rotate(360,720,410)'%3E%3Cstop offset='0' stop-color='%23ffffff'/%3E%3Cstop offset='1' stop-color='%23E5E5E5'/%3E%3C/linearGradient%3E%3Cpattern patternUnits='userSpaceOnUse' id='b' width='666' height='555' x='0' y='0' viewBox='0 0 1080 900'%3E%3Cg fill-opacity='0.04'%3E%3Cpolygon fill='%23444' points='90 150 0 300 180 300'/%3E%3Cpolygon points='90 150 180 0 0 0'/%3E%3Cpolygon fill='%23AAA' points='270 150 360 0 180 0'/%3E%3Cpolygon fill='%23DDD' points='450 150 360 300 540 300'/%3E%3Cpolygon fill='%23999' points='450 150 540 0 360 0'/%3E%3Cpolygon points='630 150 540 300 720 300'/%3E%3Cpolygon fill='%23DDD' points='630 150 720 0 540 0'/%3E%3Cpolygon fill='%23444' points='810 150 720 300 900 300'/%3E%3Cpolygon fill='%23FFF' points='810 150 900 0 720 0'/%3E%3Cpolygon fill='%23DDD' points='990 150 900 300 1080 300'/%3E%3Cpolygon fill='%23444' points='990 150 1080 0 900 0'/%3E%3Cpolygon fill='%23DDD' points='90 450 0 600 180 600'/%3E%3Cpolygon points='90 450 180 300 0 300'/%3E%3Cpolygon fill='%23666' points='270 450 180 600 360 600'/%3E%3Cpolygon fill='%23AAA' points='270 450 360 300 180 300'/%3E%3Cpolygon fill='%23DDD' points='450 450 360 600 540 600'/%3E%3Cpolygon fill='%23999' points='450 450 540 300 360 300'/%3E%3Cpolygon fill='%23999' points='630 450 540 600 720 600'/%3E%3Cpolygon fill='%23FFF' points='630 450 720 300 540 300'/%3E%3Cpolygon points='810 450 720 600 900 600'/%3E%3Cpolygon fill='%23DDD' points='810 450 900 300 720 300'/%3E%3Cpolygon fill='%23AAA' points='990 450 900 600 1080 600'/%3E%3Cpolygon fill='%23444' points='990 450 1080 300 900 300'/%3E%3Cpolygon fill='%23222' points='90 750 0 900 180 900'/%3E%3Cpolygon points='270 750 180 900 360 900'/%3E%3Cpolygon fill='%23DDD' points='270 750 360 600 180 600'/%3E%3Cpolygon points='450 750 540 600 360 600'/%3E%3Cpolygon points='630 750 540 900 720 900'/%3E%3Cpolygon fill='%23444' points='630 750 720 600 540 600'/%3E%3Cpolygon fill='%23AAA' points='810 750 720 900 900 900'/%3E%3Cpolygon fill='%23666' points='810 750 900 600 720 600'/%3E%3Cpolygon fill='%23999' points='990 750 900 900 1080 900'/%3E%3Cpolygon fill='%23999' points='180 0 90 150 270 150'/%3E%3Cpolygon fill='%23444' points='360 0 270 150 450 150'/%3E%3Cpolygon fill='%23FFF' points='540 0 450 150 630 150'/%3E%3Cpolygon points='900 0 810 150 990 150'/%3E%3Cpolygon fill='%23222' points='0 300 -90 450 90 450'/%3E%3Cpolygon fill='%23FFF' points='0 300 90 150 -90 150'/%3E%3Cpolygon fill='%23FFF' points='180 300 90 450 270 450'/%3E%3Cpolygon fill='%23666' points='180 300 270 150 90 150'/%3E%3Cpolygon fill='%23222' points='360 300 270 450 450 450'/%3E%3Cpolygon fill='%23FFF' points='360 300 450 150 270 150'/%3E%3Cpolygon fill='%23444' points='540 300 450 450 630 450'/%3E%3Cpolygon fill='%23222' points='540 300 630 150 450 150'/%3E%3Cpolygon fill='%23AAA' points='720 300 630 450 810 450'/%3E%3Cpolygon fill='%23666' points='720 300 810 150 630 150'/%3E%3Cpolygon fill='%23FFF' points='900 300 810 450 990 450'/%3E%3Cpolygon fill='%23999' points='900 300 990 150 810 150'/%3E%3Cpolygon points='0 600 -90 750 90 750'/%3E%3Cpolygon fill='%23666' points='0 600 90 450 -90 450'/%3E%3Cpolygon fill='%23AAA' points='180 600 90 750 270 750'/%3E%3Cpolygon fill='%23444' points='180 600 270 450 90 450'/%3E%3Cpolygon fill='%23444' points='360 600 270 750 450 750'/%3E%3Cpolygon fill='%23999' points='360 600 450 450 270 450'/%3E%3Cpolygon fill='%23666' points='540 600 630 450 450 450'/%3E%3Cpolygon fill='%23222' points='720 600 630 750 810 750'/%3E%3Cpolygon fill='%23FFF' points='900 600 810 750 990 750'/%3E%3Cpolygon fill='%23222' points='900 600 990 450 810 450'/%3E%3Cpolygon fill='%23DDD' points='0 900 90 750 -90 750'/%3E%3Cpolygon fill='%23444' points='180 900 270 750 90 750'/%3E%3Cpolygon fill='%23FFF' points='360 900 450 750 270 750'/%3E%3Cpolygon fill='%23AAA' points='540 900 630 750 450 750'/%3E%3Cpolygon fill='%23FFF' points='720 900 810 750 630 750'/%3E%3Cpolygon fill='%23222' points='900 900 990 750 810 750'/%3E%3Cpolygon fill='%23222' points='1080 300 990 450 1170 450'/%3E%3Cpolygon fill='%23FFF' points='1080 300 1170 150 990 150'/%3E%3Cpolygon points='1080 600 990 750 1170 750'/%3E%3Cpolygon fill='%23666' points='1080 600 1170 450 990 450'/%3E%3Cpolygon fill='%23DDD' points='1080 900 1170 750 990 750'/%3E%3C/g%3E%3C/pattern%3E%3C/defs%3E%3Crect x='0' y='0' fill='url(%23a)' width='100%25' height='100%25'/%3E%3Crect x='0' y='0' fill='url(%23b)' width='100%25' height='100%25'/%3E%3C/svg%3E");
				background-attachment: fixed;
				background-size: cover;
				
				background-position: center center;
			}

			a {
				color: #f00;
			}
			
			.annotation-marker{
				position: absolute;
			    	border-radius: 50%;
			    	cursor: pointer;
			    	padding: 0;
			    	margin: 0;
			    	border: 2px solid #dddc;
			    	background: #00000061;
			    	padding: 1px 9px;
			    	transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
				opacity:0;
			}
			
			.annotation-marker span{
				font-size: 13px;
				font-weight: 600;
				color: white;
			}

			#annotation-description{
				position: absolute;
			    bottom: 0;
			    left: 0;
			    width: 100vw;
			    background: #7b82ea75;
			    height: 0;
			    padding: 16px;
			    color: #ffffff;
			    font-size: 1.15rem;
			    backdrop-filter: blur(12px);
			    opacity:0;
			}

			#splash{
				position: fixed;
				width:1vw;
				height:1vw;
				transition: transform 1s cubic-bezier(0.4, 0, 0.2, 1);
				border-radius: 50%;
				top:50%;
				left:50%;
				background: #7683eb;
				z-index:500;
			}

			
			#loadingtext {
			  position: absolute;
			    z-index: 600;
			    color: white;
			    left: 0%;
			    transform: translate(-50%) !important;
			    top: 47%;
			    text-transform: uppercase;
			    font: 1000 4em/1 "Nunito", sans-serif;
			    letter-spacing: 6px;
			    filter: drop-shadow(2px 4px 6px #333) brightness(1.2);
			    /* font-weight: 800; */
			    padding: 0.25em 0 0.325em;
			    display: block;
			    margin: 0 auto;
			    text-shadow: 0 0 80px rgb(255 255 255 / 50%);
			    background: url(https://i.ibb.co/RDTnNrT/animated-text-fill.png) repeat-y;
			    -webkit-background-clip: text;
			    background-clip: text;
			    -webkit-text-fill-color: transparent;
			    -webkit-animation: aitf 80s linear infinite;
			    -webkit-transform: translate3d(0, 0, 0);
			    -webkit-backface-visibility: hidden;
			     transition: opacity 0.3s ease-in-out;
			     opacity:0;
			}

			
			@-webkit-keyframes aitf {
			  0% {
			    background-position: 0% 50%;
			  }
			  100% {
			    background-position: 100% 50%;
			  }
			}

			.frame {
			  position: absolute;
			  top: 35%;
			  left: 50%;
			  width: 400px;
			  height: 400px;
			  margin-top: -200px;
			  margin-left: -200px;
			  border-radius: 2px;
			  z-index:600;
			  color: #fff;
			  opacity:0;
			  transition: opacity 0.9s ease-in-out;
			}

			.center {
			  position: absolute;
			  width: 220px;
			  height: 220px;
			  top: 90px;
			  left: 90px;
			  transform: scale(1.1);
    			  opacity: 0.9;
			}
			

			.dot-1 {
			  position: absolute;
			  z-index: 3;
			  width: 30px;
			  height: 30px;
			  top: 95px;
			  left: 95px;
			  background: #f16441;
			  border-radius: 50%;
			  -webkit-animation-fill-mode: both;
				  animation-fill-mode: both;
			  -webkit-animation: jump-jump-1 2s cubic-bezier(0.21, 0.98, 0.6, 0.99) infinite alternate;
				  animation: jump-jump-1 2s cubic-bezier(0.21, 0.98, 0.6, 0.99) infinite alternate;
			}

			
			
			
			#ar-cta{
			    background: white;
			    /* border: none; */
			    text-transform: capitalize;
			    padding: 0.4rem 1rem;
			    border-radius: 8rem;
			    background: #f7f7f7;
			    top: 16px;
			    right: 16px;
			    position: absolute;
			    color: #7683eb;
			    font-family: inherit;
			    font-size: 0.9rem;
			    border: 2px solid #7683eb;
			    outline: none;
			    font-weight: bold;
			    box-shadow: 0px 5px 16px 1px rgb(118 131 235 / 46%);
			}

			#params-hldr{
				position: absolute;
				width: 300px;
				padding: 1rem;
				top: 5%;
				left: 5%;
				z-index: 100;
			}

			.form-hldr {
    			margin-bottom: 1rem;
			}

			.form-hldr input{
				width: 30px;
    			margin: 0 0 0 0.8rem;
				text-align: center;
			}

			button{
				background: #4d4dea;
				color: white;
				padding: 0.3rem 1rem;
				outline: none;
				box-shadow: none;
				border-radius: 4px;
				font-size: 0.9rem;
				border: none;
				text-transform: capitalize;
			}

			#info-hldr {
					position: absolute;
					z-index: 110;
					top: 27%;
					left: 10%;
					background: #e5e6fae3;
					padding: 0.7rem 0.6rem;
					border-radius: 5px;
					box-shadow: 1px 1px 10px 1px rgb(0 0 0 / 20%);
					transition: 0.3s ease-in-out;
					opacity: 0;
			}

			#info-hldr .item {
				/* font-size: 0.8rem; */
				font-weight: bold;
				color: #333;
			}

			.depthInput{
				max-width: 1.1rem;
			}

			
		</style>
		<script>
		 var camerag, sceneg, meshg;
		</script>
	</head>

	<body>
		
		<div id="annotation-markers">
			
		</div>
		<div id="annotation-description">
			
		</div>

		<div id="info-hldr">
			<div class="item">
				<span class="field-value"></span>
			</div>

			<div class="item">
				<span class="field-value"></span>
			</div>

			<div class="item">
				<span class="field-value"></span>
			</div>
			
		</div>


		<script type="module">

			import * as THREE from './build/three.module.js';

			import { GLTFLoader } from './jsm/GLTFLoader.js';

			import { OrbitControls } from './jsm/OrbitControls.js';

			import { RoomEnvironment } from './jsm/RoomEnvironment.js';

            import { EffectComposer } from './jsm/EffectComposer.js';
			import { SSAOPass } from './jsm/SSAOPass.js';

            import { GUI } from './jsm/lil-gui.module.min.js';

			let camera, controls, scene, renderer, pmremGenerator;
 
            let composer;

			let adjustedCanvasWidth, adjustedCanvasHeight;
			let meshPos;
			let mouse = {}, raycaster; 

            const depthParams = {
                "1": 1.0,
                "2": 1.15, 
                "3": 1.35,
                "4": 1.55,
				/*"clip": 1.00,*/
            }

			let box, currentLayer, currentDepth, rail;

			let concreteTexture, roughBumpTexture, wallAOMap, wallTexture2;

			let namesToIndex = {}, jugaadCounter = 0, animateFlag = false;

			let info = {
				"1": {
						"manufacturer": "Some Manufacturer",
						"info": "A2 fire rated",
						"depth": "100 mm",
				},
				"2": {
						"manufacturer": "Some Manufacturer2",
						"info": "A2 fire rated",
						"depth": "100 mm",
				},
				"3": {
						"manufacturer": "Some Manufacturer3",
						"info": "A2 fire rated",
						"depth": "100 mm",
				},
				"4": {
						"manufacturer": "Some Manufacturer4",
						"info": "A2 fire rated",
						"depth": "100 mm",
				},
			};

			let jsonData;

			let levels = ["1",["bracket1", "bracket2", "2"], ["plate1", "plate2"], "3","4"];

            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0x7a2408, 0x571e6f, 0xcaba23 , 0xd969ae, 0x30c2b5, 0xbc3b62, 0x99fda1]

			const infoHolder = document.getElementById('info-hldr');

			const loader = new GLTFLoader();

			let sceneLayers = {}, hadFoundChild = false, maxDepth =0, maxDepthLayerId = undefined;

			getData();
			 //init();
			 //animate();

			function getData(){
				//load json file

                fetch('https://divc.sfs.com/pb-visual/')
                .then((response) => response.json())
                .then((json) => {
                    init(json);
                    //createLayers(json);
                });
			}

			function init(json) {

				console.log('init called');
				
				
				scene = new THREE.Scene();
				sceneg = scene;
				//scene.background = new THREE.Color( 0xcccccc );
				scene.background = null;
				

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				renderer.outputEncoding = THREE.sRGBEncoding;
				//renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.toneMappingExposure = 1.0;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );


				pmremGenerator = new THREE.PMREMGenerator( renderer );
				//pmremGenerator.compileEquirectangularShader();

				scene.environment = pmremGenerator.fromScene( new RoomEnvironment(), 0.04 ).texture;


				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				//camera.position.set( 400, 200, 0 );
                camera.position.set(2, 4, 100);
				camerag = camera;

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				
				controls.enableDamping = true; 
				controls.dampingFactor = 0.05;

				controls.screenSpacePanning = false;

				const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
				scene.add(ambientLight);

				//controls.minDistance = 1;
				//controls.maxDistance = 500;
				//controls.autoRotate = true;
				//controls.autoRotateSpeed = 0.5;

				//controls.maxPolarAngle = Math.PI / 2;

               // composer = new EffectComposer( renderer );

                /*
                const ssaoPass = new SSAOPass( scene, camera, window.innerWidth, window.innerHeight );
                ssaoPass.kernelRadius = 22.56;
                ssaoPass.minDistance = 0.001;
                ssaoPass.maxDistance = 0.078;
                ssaoPass.output = parseInt(SSAOPass.OUTPUT.Beauty);
                composer.addPass( ssaoPass );
                */

                // Init gui
				/*const gui = new GUI();

                gui.add( ssaoPass, 'output', {
                    'Default': SSAOPass.OUTPUT.Default,
                    'SSAO Only': SSAOPass.OUTPUT.SSAO,
                    'SSAO Only + Blur': SSAOPass.OUTPUT.Blur,
                    'Beauty': SSAOPass.OUTPUT.Beauty,
                    'Depth': SSAOPass.OUTPUT.Depth,
                    'Normal': SSAOPass.OUTPUT.Normal
                } ).onChange( function ( value ) {

                    ssaoPass.output = parseInt( value );

                } );
                gui.add( ssaoPass, 'kernelRadius' ).min( 0 ).max( 32 );
                gui.add( ssaoPass, 'minDistance' ).min( 0.001 ).max( 0.02 );
                gui.add( ssaoPass, 'maxDistance' ).min( 0.01 ).max( 0.3 );*/

				
				adjustedCanvasWidth = renderer.domElement.width / window.devicePixelRatio;
				adjustedCanvasHeight = renderer.domElement.height / window.devicePixelRatio;

				
				raycaster = new THREE.Raycaster();

				concreteTexture = new THREE.TextureLoader().load( "./assets/concrete_tex.jpeg" );
				concreteTexture.wrapS = THREE.RepeatWrapping;
				concreteTexture.wrapT = THREE.RepeatWrapping;
				concreteTexture.repeat.set( 6, 6 );

				wallTexture2 = new THREE.TextureLoader().load( "./assets/bricktex.jpeg" );
				wallTexture2.rotation = -Math.PI / 2.0;
				wallTexture2.wrapS = THREE.RepeatWrapping;
				wallTexture2.wrapT = THREE.RepeatWrapping;
				wallTexture2.repeat.set( 8, 8 );


				roughBumpTexture = new THREE.TextureLoader().load( "./assets/rough_bump.jpeg" );
				roughBumpTexture.wrapS = THREE.RepeatWrapping;
				roughBumpTexture.wrapT = THREE.RepeatWrapping;
				roughBumpTexture.repeat.set( 3, 3 );

				wallAOMap = new THREE.TextureLoader().load( "./assets/painted_ao.jpeg" );

				

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener('pointerdown', raycast);


                animate();
                loadModelFile(json);
                //createLayers(json);
			}


            function createLayers(json){
                console.log(json);

				jsonData = json;
				
                json.LayersArray.forEach((el, index) => {
                    
                    const geometry = box.clone().children[0].geometry;
                    //console.log(box);
                    
                    //const geometry = new THREE.BoxGeometry( 4, 2, 1 );
                    
                    const material = new THREE.MeshStandardMaterial( {color: parseInt(el.HexColour.replace(/^#/, ''), 16), metalness: 0.8, roughness: 0.5, transparent: true} );
                    
					material.opacity = el.Opacity;
					
					/*
					if(el.MaterialType === "Air"){
						material.opacity = 0.2;
					}
					*/
					
					
					const cube = new THREE.Mesh( geometry, material );
                    cube.position.y = 0;
					cube.position.x = 0;
					

                    //cube.scale.x *= 15.0;
					cube.scale.x *= parseFloat(el.WidthM) * 4.0;
                    //cube.scale.y *= 5.0 + (index +1) * 1.5;
					cube.scale.y *= parseFloat(el.HeightM) * 4.0;
                    cube.scale.z *= parseFloat(el.DepthMM) * 0.04;

                    cube.position.y += cube.scale.y + parseFloat(el.OffsetY);
					//cube.position.z += parseFloat(el.OffsetY);
                    cube.position.x += -parseFloat(el.OffsetX);

                    if(index > 0){

						let lowerLayer;

						if(el.ParentId === "0"){
							const lowerLayerId = json.LayersArray[index - 1].Id;
							lowerLayer = sceneLayers[lowerLayerId];
							
							if(hadFoundChild){
								
								lowerLayer = sceneLayers[maxDepthLayerId];
								hadFoundChild = false;
								maxDepth = 0;
								
							}

						}else{

							hadFoundChild = true;

							const lowerLayerId = (parseInt(el.ParentId) - 1).toString();
							lowerLayer = sceneLayers[lowerLayerId];
							cube.scale.x *= 0.8;
							cube.scale.y *= 0.8;

							const depth = parseFloat(el.DepthMM);
							if(depth > maxDepth){
								maxDepth = depth;
								maxDepthLayerId = el.Id;
							}
								
						}
                        
                        //console.log(lowerLayer);

                        lowerLayer.geometry.computeBoundingBox();

                        const boxx = new THREE.Box3();
						lowerLayer.updateMatrixWorld( true );
						boxx.copy( lowerLayer.geometry.boundingBox ).applyMatrix4( lowerLayer.matrixWorld );
                        
                        cube.position.z = boxx.max.z + parseFloat(el.OffsetZ);
                    }

                    
					sceneLayers[el.Id] = cube; 

                    //cube.scale.set(1000,1000,1000);
                    scene.add( cube );

					
                });

				//loadRailModel();
				createRails();
				createBrackets();
            }

			function loadModelFile(json) {

				let indexCounter = 0;
				
				
                loader.load('./assets/box.glb', function ( gltf ) {

						
							box = gltf.scene;

							createLayers(json);


						});	    
				 
			
			}

			function loadRailModel(){
				loader.load( './assets/lrail.glb', function ( gltf ) {
	
					rail = gltf.scene;

					rail.traverse((child) => {
						if(child.isMesh){
							child.material = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.2, metalness: 0.6})
						}
					});

					//rail.material.color.set(0x333333);

					rail.scale.multiplyScalar(10);
					rail.rotation.x += Math.PI / 2.0;

					rail.position.y = 0;
					//rail.position.z = 10;

					scene.add(gltf.scene);

					createRails();


				});
			}

			function createRails(){
				jsonData.RailsArray.forEach((el, index) => {
					
					loader.load('./assets/rail2.glb', function ( gltf ) {

						const geometry = box.clone().children[0].geometry;
						const material = new THREE.MeshStandardMaterial( {color: 0xaaaaaa, metalness: 0.8, roughness: 0.8} );

						const rail = new THREE.Mesh(geometry, material);

						/*
						gltf.scene.traverse((child) => {
							if(child.isMesh){
								child.material = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.2, metalness: 0.6})
							}
						});

						*/
						
						//rail.scale.multiplyScalar(2.0);


						
						rail.position.y = 12;
						

						rail.scale.y *= parseFloat(el.RailLengthM) * 4.0;
						rail.scale.z *= 0.1;
						rail.scale.x *= 0.8;


						
						//rail.rotation.x += Math.PI / 2.0;
						//srail.rotation.z += Math.PI / 2.0;
						//rail.rotation.y += Math.PI / 2.0;

						if(el.Orientation === "Horizontal"){
							rail.rotation.z = Math.PI / 2.0;
							rail.rotation.y = 0;
							rail.rotation.x = Math.PI / 2.0;
						}
						
						/*
						const rbox = new THREE.Box3();
						rail.children[0].geometry.computeBoundingBox();
						rail.children[0].updateMatrixWorld(true);
						rbox.copy( rail.children[0].geometry.boundingBox ).applyMatrix4( rail.children[0].matrixWorld );
						
						console.log(rbox);
						rail.position.y += rbox.max.y * 40.0;
						*/
						

						let lowerLayer = sceneLayers[el.ParentLayerId];
						lowerLayer.geometry.computeBoundingBox();

                        const boxx = new THREE.Box3();
						lowerLayer.updateMatrixWorld( true );
						boxx.copy( lowerLayer.geometry.boundingBox ).applyMatrix4( lowerLayer.matrixWorld );

						rail.position.z = boxx.max.z;
						//rail.position.z = 0;

						rail.position.x = (parseFloat(el.LeftEdgeDistanceM) - (parseFloat(jsonData["StageAreaConfiguration"][0]["WallAreaHorizontalM"]) / 2.0)) * 7.5;

						scene.add(rail);

					});
					
					
					
				})
			}

			function createBrackets() {
				jsonData.ComponentsArray.forEach((el, index) => {
					const geometry = box.clone().children[0].geometry;
					const material = new THREE.MeshStandardMaterial( {color: 0x333333, metalness: 0.8, roughness: 0.5 } );

					const bracket = new THREE.Mesh(geometry, material);

					bracket.scale.z *= 0.1;
					bracket.scale.x *= 0.5;
					bracket.scale.y *= 0.5;

					const lowerLayer = sceneLayers[el.ParentLayerId];

					const boxx = new THREE.Box3();
					lowerLayer.updateMatrixWorld( true );
					boxx.copy( lowerLayer.geometry.boundingBox ).applyMatrix4( lowerLayer.matrixWorld );

					bracket.position.z = boxx.max.z + parseFloat(el.OffsetZ);

					bracket.position.x = (parseFloat(el.LeftEdgeDistanceM) - (parseFloat(jsonData["StageAreaConfiguration"][0]["WallAreaHorizontalM"]) / 2.0)) * 7.5 + parseFloat(el.OffsetX);
					bracket.position.y = (-parseFloat(el.TopEdgeDistanceM) + (parseFloat(jsonData["StageAreaConfiguration"][0]["WallAreaVerticalM"]))) * 7.5 + parseFloat(el.OffsetY);

					scene.add(bracket);

				});
			}

			function setChildIndex(childName, index){
				namesToIndex[childName] = index;
			}

			function getChildIndex(childName){
				return parseInt(namesToIndex[childName]);
			}

			function handleResizeOp(layerNumber, depth){

					//1, 2, 3, 4
				
				/*
					//console.log(layerNumber);
					if(layerNumber == undefined){
						layerNumber = parseInt(document.getElementById('layer-seq-input').value);
					}

					if(depth == undefined){
						depth = parseInt(document.getElementById('layer-depth-input').value);
					}

					depth = depth / 10.00;
				
					//scale unit 1 has 0.39 depth
					const scalePosUnitFactor = 0.39;
					 //scale the selected child
					 const children = objectGroup.children;

					 if(layerNumber === 1){

						//if(depthParams[layerNumber] !== 1.00){
						
						
							const realDepth = (1.00 / depthParams[layerNumber]) * depth;
						console.log(realDepth);
					 	children[getChildIndex('1')].scale.x *= realDepth;
						const distanceToMove = (depthParams[layerNumber] - depth) * 0.5 * scalePosUnitFactor; 
						//children[layerNumber - 1].position.x -= distanceToMove; 

						//if(depth <= 1.0){
							children[getChildIndex('2')].position.x -= distanceToMove;
							children[getChildIndex('3')].position.x -= distanceToMove;
							children[getChildIndex('4')].position.x -= distanceToMove;

							children[getChildIndex('plate1')].position.x -= distanceToMove;
							children[getChildIndex('plate2')].position.x -= distanceToMove;
							children[getChildIndex('plate3')].position.x -= distanceToMove;
							children[getChildIndex('plate4')].position.x -= distanceToMove;

							children[getChildIndex('bracket1')].position.x -= distanceToMove;
							children[getChildIndex('bracket2')].position.x -= distanceToMove;

							//children[getChildIndex('cb1')].position.x -= distanceToMove;
							//children[getChildIndex('cb2')].position.x -= distanceToMove;
							//children[getChildIndex('cb3')].position.x -= distanceToMove;
							//children[getChildIndex('clip1')].position.x -= distanceToMove;
							//children[getChildIndex('clip2')].position.x -= distanceToMove;
							

						//}

						
						depthParams[layerNumber] = depth; 
					 //}
					 
					}else if(layerNumber == 2){
						
						const realDepth = (1.00 / depthParams[layerNumber]) * depth;
						console.log(realDepth);
					 	children[getChildIndex('2')].scale.x *= realDepth;
						const distanceToMove = (depthParams[layerNumber] - depth) * 0.5 * scalePosUnitFactor; 
						children[getChildIndex('2')].position.x -= distanceToMove; 

						//if(depth <= 1.0){
							children[getChildIndex('3')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('4')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate1')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate2')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate3')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate4')].position.x -= distanceToMove * 2.0;
							
							children[getChildIndex('bracket1')].scale.z *= realDepth;
							children[getChildIndex('bracket1')].position.x -= distanceToMove * 3.0;

							children[getChildIndex('bracket2')].scale.z *= realDepth;
							children[getChildIndex('bracket2')].position.x -= distanceToMove * 3.0;

							//children[getChildIndex('cb1')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('cb2')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('cb3')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('clip1')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('clip2')].position.x -= distanceToMove * 2.0;

							//children[layerNumber + 7].position.x -= distanceToMove * 2.0;
							
						//}

						
						depthParams[layerNumber] = depth; 
						//depthParams[layerNumber] = depth; 

					}else if(layerNumber == 3){
						const realDepth = (1.00 / depthParams[layerNumber]) * depth;
						console.log(realDepth);
					 	children[getChildIndex('3')].scale.x *= realDepth;
						const distanceToMove = (depthParams[layerNumber] - depth) * 0.5 * scalePosUnitFactor; 
						children[getChildIndex('3')].position.x -= distanceToMove; 

						//if(depth <= 1.0){
							children[getChildIndex('4')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate3')].position.x -= distanceToMove * 2.0;
							children[getChildIndex('plate4')].position.x -= distanceToMove * 2.0;

							//children[getChildIndex('cb1')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('cb2')].position.x -= distanceToMove *2.0;
							//children[getChildIndex('cb3')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('clip1')].position.x -= distanceToMove * 2.0;
							//children[getChildIndex('clip2')].position.x -= distanceToMove * 2.0;
							//children[layerNumber + 1].position.x -= distanceToMove * 2.0;
						//}

						
						depthParams[layerNumber] = depth; 
					}else if(layerNumber == 4){
						const realDepth = (1.00 / depthParams[layerNumber]) * depth;
						console.log(realDepth);
					 	children[getChildIndex('4')].scale.x *= realDepth;
						const distanceToMove = (depthParams[layerNumber] - depth) * 0.5 * scalePosUnitFactor; 
						children[getChildIndex('4')].position.x -= distanceToMove; 
						children[getChildIndex('plate3')].position.x -= distanceToMove * 2.0;
						children[getChildIndex('plate4')].position.x -= distanceToMove * 2.0;

						//children[getChildIndex('clip1')].scale.y *= ((realDepth * 0.6) / depthParams['clip']);

						//children[getChildIndex('clip2')].scale.y *= ((realDepth * 0.6) / depthParams['clip']);
						//children[getChildIndex('clip2')].position.x -= distanceToMove * 3.0;

						//if(depth <= 1.0){
							//children[layerNumber].position.x -= distanceToMove * 2.0;
							//children[layerNumber + 1].position.x -= distanceToMove * 2.0;
						//}

						
						depthParams[layerNumber] = depth; 
						depthParams['clip'] = realDepth * 0.60;
					}else{

					} */

					scene.getObjectByName('nv90uni').visible = false;
					scene.getObjectByName('nv150uni').visible = false;
					scene.getObjectByName('nv240uni').visible = false;

					
					for(let key in depthParams){
						const layer = scene.getObjectByName(key);
						layer.scale.x *= depthParams[key]; 
					} 

				
					 

					for (let i=0; i < (levels.length-1); i++ ){
						console.log('inside');
						let higherLayer = levels[i+1];
						let lowerLayer = levels[i];
						
						if(Array.isArray(lowerLayer)){
							if(lowerLayer[0].includes('nv')){
								console.log('lower layer is bracket 1');
								lowerLayer = levels[i-1];

								if(Array.isArray[lowerLayer]){
									lowerLayer = scene.getObjectByName(lowerLayer[0]);
								}else{
									lowerLayer = scene.getObjectByName(lowerLayer);
								}
							}

							

							lowerLayer = scene.getObjectByName(lowerLayer[0]);
						}else{

							if(lowerLayer.includes('nv')){
								console.log('lower layer is bracket 2');
								lowerLayer = levels[i-1];

								if(Array.isArray[lowerLayer]){
									lowerLayer = scene.getObjectByName(lowerLayer[0]);
								}else{
									lowerLayer = scene.getObjectByName(lowerLayer);
								}
							}else{
								lowerLayer = scene.getObjectByName(lowerLayer);
							}

							

							
							console.log(lowerLayer);
							
						}

						
						
						lowerLayer.geometry.computeBoundingBox();


						const box = new THREE.Box3();
						lowerLayer.updateMatrixWorld( true );
						box.copy( lowerLayer.geometry.boundingBox ).applyMatrix4( lowerLayer.matrixWorld );
						console.log(box);

						
						
						if(Array.isArray(higherLayer)){
							higherLayer.forEach((m) => {
								scene.getObjectByName(m).position.x = box.max.x; 
								scene.getObjectByName(m).visible = true;
							});
						}else{
							scene.getObjectByName(higherLayer).position.x = box.max.x; 
							scene.getObjectByName(higherLayer).visible = true;
						}
						
					}
					

					

					//handleResizeOp(i, i++);

					 

			}	

			function handleVisualize(){

				jugaadCounter = 0;

				/*depthParams[1] = 1.0;
				depthParams[2] = 1.0;
				depthParams[3] = 1.0;
				depthParams[4] = 1.0;*/

				//scene.clear();
				//getData();

				//scene.clear();


				levels = [];
				
				levels.push(document.getElementById('select1').value);
				levels.push(document.getElementById('select2').value);
				levels.push(document.getElementById('select3').value);
				levels.push(document.getElementById('select4').value);
				levels.push(document.getElementById('select5').value);
				levels.push(document.getElementById('select6').value);
				

				//scene.clear();

				handleResizeOp();


			}

			window.handleResizeOp = handleResizeOp;
			window.handleVisualize = handleVisualize;

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				adjustedCanvasWidth = renderer.domElement.width / window.devicePixelRatio;
				adjustedCanvasHeight = renderer.domElement.height / window.devicePixelRatio;

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update(); 

				render();

				

			}

			function render() {

				//if(objectGroup) objectGroup.rotation.y += 0.01;

				renderer.render( scene, camera );

                //composer.render();

			}
		
			
			function raycast(event){
				
				//controls.autoRotate = false;
				//setTimeout(() => (controls.autoRotate = true), 8000);
				
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				
				const intersects = raycaster.intersectObjects( scene.children, true );

				if(intersects.length > 0){

					//intersects[ i ].object.material.color.set( 0xff0000 );
					const selectedObjectName = intersects[0].object.name;
					console.log(selectedObjectName);

					const selectedObjectInfo = info[parseInt(selectedObjectName) -1];

					//const infoHolder = document.getElementById('info-hldr');

					if(infoHolder.style.opacity !== 1.0) infoHolder.style.opacity = 1.0;

					infoHolder.children[0].innerHTML = '&bull; ' + selectedObjectInfo.manufacture_name + ' (manufacturer)';
					infoHolder.children[1].innerHTML = '&bull; ' + 'Depth ' + selectedObjectInfo.lyer_depth_mm + ' mm';
					infoHolder.children[2].innerHTML = '&bull; ' + 'Fire Rating: ' + selectedObjectInfo.fire_ratings;

					infoHolder.style.top = event.clientY + 10 +'px';
					infoHolder.style.left = event.clientX + 10 +'px';

					setTimeout(() => {
						infoHolder.style.opacity = 0;
					}, 5000);

				}else{
					if(infoHolder.style.opacity == 1.0) infoHolder.style.opacity = 0; 
				}



			}
			

		</script>

	</body>
</html>

